<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Security Headers (Meta-equivalent) -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; object-src 'none'; base-uri 'self';">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="no-referrer">

    <!-- Primary SEO -->
    <title>IPv6Gen.net | Vanity IPv6 Address Generator & Hexspeak Tool</title>
    <meta name="description" content="Generate valid vanity IPv6 addresses instantly. Convert text to Hexspeak (Leet) or ASCII. The essential tool for network engineers, sysadmins, and homelab builders.">
    <meta name="keywords" content="ipv6 generator, vanity ipv6 address, hexspeak converter, ipv6 calculator, subnet tool, network engineering, leetspeak to hex, interface identifier">
    <meta name="author" content="IPv6Gen.net">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://ipv6gen.net/">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ipv6gen.net/">
    <meta property="og:title" content="IPv6Gen.net | Vanity IPv6 Address Generator">
    <meta property="og:description" content="Turn words into valid IPv6 addresses. The smartest Hexspeak tool for your network infrastructure.">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ipv6gen.net/">
    <meta property="twitter:title" content="IPv6Gen.net | Vanity IPv6 Address Generator">

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>v6</text></svg>">

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "IPv6Gen Vanity Generator",
      "operatingSystem": "Web Browser",
      "applicationCategory": "NetworkTool",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "A web-based tool to generate valid vanity IPv6 addresses using Hexspeak and Leetspeak mappings."
    }
    </script>

    <style>
        :root {
            --bg-color: #0d1117;
            --term-green: #00ff41;
            --term-dim: #008f11;
            --text-color: #c9d1d9;
            --accent: #58a6ff;
            --err: #ff7b72;
            --warn: #d29922;
            --font-stack: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-stack);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        a { color: var(--accent); text-decoration: none; }
        a:hover { text-decoration: underline; }

        .container {
            max-width: 900px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        header {
            text-align: center;
            border-bottom: 1px solid #30363d;
            padding-bottom: 2rem;
            margin-bottom: 1rem;
        }

        h1 {
            color: var(--term-green);
            margin: 0;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            color: #8b949e;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        /* Controls Area */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            background: #161b22;
            padding: 2rem;
            border-radius: 6px;
            border: 1px solid #30363d;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }

        label {
            font-size: 0.8rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
        }

        input[type="text"] {
            background: #0d1117;
            border: 1px solid #30363d;
            color: var(--term-green);
            font-family: var(--font-stack);
            font-size: 1.5rem;
            padding: 1rem;
            border-radius: 4px;
            outline: none;
            width: 100%;
            transition: border-color 0.2s;
        }

        input[type="text"]::placeholder { color: #30363d; }
        input[type="text"]:focus {
            border-color: var(--term-green);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.1);
        }
        
        input[type="text"].invalid {
            border-color: var(--err);
        }

        /* Toggle Switch */
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #8b949e;
        }
        .toggle-wrapper input { display: none; }
        .slider {
            width: 36px; height: 20px; background: #30363d;
            border-radius: 20px; position: relative; transition: 0.3s;
        }
        .slider::before {
            content: ""; position: absolute; height: 16px; width: 16px;
            left: 2px; bottom: 2px; background: white; border-radius: 50%;
            transition: 0.3s;
        }
        input:checked + .slider { background: var(--term-green); }
        input:checked + .slider::before { transform: translateX(16px); }


        /* Results Area */
        .results {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .result-card {
            background: #000;
            border: 1px solid #30363d;
            padding: 1.5rem;
            border-radius: 6px;
            position: relative;
            transition: border-color 0.2s;
        }

        .result-card:hover { border-color: var(--term-dim); }

        .card-label {
            position: absolute;
            top: -10px;
            left: 20px;
            background: #000;
            padding: 0 10px;
            color: #8b949e;
            font-size: 0.8rem;
            border: 1px solid #30363d;
            border-radius: 4px;
        }

        .ip-address {
            font-size: 1.4rem;
            word-break: break-all;
            margin-top: 0.5rem;
            cursor: pointer;
        }

        .prefix-part { color: #484f58; }
        .vanity-part { color: var(--term-green); font-weight: bold; }
        .error-part { color: var(--err); text-decoration: underline wavy; }
        .sep-part { color: var(--accent); opacity: 0.7; }
        
        .copy-icon {
            position: absolute;
            right: 20px;
            top: 20px;
            opacity: 0;
            transition: opacity 0.2s;
            color: #484f58;
        }
        .result-card:hover .copy-icon { opacity: 1; }

        /* Suggestions Box */
        .suggestions-box {
            display: none; 
            background: #161b22;
            border: 1px dashed var(--warn);
            padding: 1.5rem;
            border-radius: 6px;
        }

        .suggestions-box h4 {
            margin: 0 0 10px 0;
            color: var(--warn);
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .suggestion-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #0d1117;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid #30363d;
            border-radius: 4px;
            cursor: pointer;
        }
        .suggestion-item:hover { border-color: var(--term-green); }

        .sugg-val { color: var(--term-green); font-family: var(--font-stack); }
        .sugg-label { font-size: 0.8rem; color: #8b949e; }
        .sugg-diff { color: var(--accent); font-size: 0.75rem; margin-left: 10px; }

        /* Hex Chart */
        .hex-chart {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 2rem;
        }

        .chart-item {
            background: #161b22;
            border: 1px solid #30363d;
            padding: 10px;
            text-align: center;
            border-radius: 4px;
        }

        .char-key { font-size: 1.2rem; color: var(--text-color); font-weight: bold; }
        .hex-val { font-size: 0.9rem; color: var(--term-green); margin-top: 4px; }
        .hex-val::before { content: "0x"; opacity: 0.5; font-size: 0.7rem; }

        .explanation {
            margin-top: 2rem;
            border-top: 1px solid #30363d;
            padding-top: 2rem;
            color: #8b949e;
            line-height: 1.6;
            font-size: 0.9rem;
        }
        
        .seo-content {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: #484f58;
        }
        
        strong { color: var(--text-color); }
        
        footer {
            margin-top: 3rem;
            text-align: center;
            font-size: 0.8rem;
            color: #484f58;
            border-top: 1px solid #30363d;
            padding-top: 1rem;
            width: 100%;
        }

        /* Toast Notification */
        #toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 4px;
            padding: 16px;
            position: fixed;
            z-index: 1;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            font-size: 1rem;
            border: 1px solid var(--term-green);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        #toast.show {
            visibility: visible;
            animation: fadein 0.5s, fadeout 0.5s 2.5s;
        }

        @keyframes fadein {
            from {bottom: 0; opacity: 0;}
            to {bottom: 30px; opacity: 1;}
        }

        @keyframes fadeout {
            from {bottom: 30px; opacity: 1;}
            to {bottom: 0; opacity: 0;}
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>IPv6Gen.net</h1>
        <div class="subtitle">The Advanced Vanity IPv6 Address Generator & Hexspeak Translator</div>
    </header>

    <div class="controls">
        <div class="input-group">
            <label for="prefixInput">Network Prefix (e.g., 2001:db8)</label>
            <input type="text" id="prefixInput" value="2001:db8" spellcheck="false" aria-label="IPv6 Network Prefix">
        </div>
        <div class="input-group">
            <label for="textInput">
                Vanity Text / Phrase
                <label class="toggle-wrapper" title="Force creative/phonetic mappings">
                    <input type="checkbox" id="creativeToggle">
                    <span class="slider"></span>
                    <span>Creative Mode</span>
                </label>
            </label>
            <input type="text" id="textInput" placeholder="dead beef cafe" maxlength="32" autofocus spellcheck="false" aria-label="Text to convert to IPv6">
        </div>
    </div>

    <div class="results">
        
        <!-- Leetspeak Result -->
        <div class="result-card" id="leetCard">
            <span class="card-label">Visual Hexspeak (Leet Mode)</span>
            <div class="ip-address" id="leetOutput">
                <span class="prefix-part">2001:db8::</span>
                <span class="vanity-part">...</span>
            </div>
            <div class="copy-icon">ðŸ“‹</div>
        </div>

        <!-- Suggestions (Hidden unless error) -->
        <div class="suggestions-box" id="suggestionsBox">
            <h4>Suggestions</h4>
            <div id="suggestionsList"></div>
        </div>

        <!-- ASCII Result -->
        <div class="result-card" id="asciiCard">
            <span class="card-label">Literal ASCII (Encoding Mode)</span>
            <div class="ip-address" id="asciiOutput">
                <span class="prefix-part">2001:db8::</span>
                <span class="vanity-part">...</span>
            </div>
            <div class="copy-icon">ðŸ“‹</div>
        </div>

    </div>

    <div class="explanation">
        <h3>How to Read & Write Hexspeak</h3>
        <p>IPv6 addresses are 128-bit numbers written in <strong>Hexadecimal</strong> (0-9, A-F). Unlike IPv4, the vast address space of IPv6 allows network engineers to embed words, names, or phrases into the Interface Identifier (the last 64 bits) of the address.</p>
        
        <p><strong>IPv6Gen.net</strong> automatically translates your text using two methods:</p>
        <ul>
            <li><strong>Hexspeak (Leet):</strong> Visually mapping letters to numbers (e.g., 'S' &rarr; '5', 'T' &rarr; '7'). Perfect for readable "Vanity" addresses like <code>::dead:beef</code>.</li>
            <li><strong>ASCII Encoding:</strong> Converts the raw byte values of text into hex (e.g., 'hi' &rarr; <code>::6869</code>). This guarantees a valid address for ANY text.</li>
        </ul>

        <div class="hex-chart">
            <div class="chart-item"><div class="char-key">O</div><div class="hex-val">0</div></div>
            <div class="chart-item"><div class="char-key">I / L</div><div class="hex-val">1</div></div>
            <div class="chart-item"><div class="char-key">Z / R</div><div class="hex-val">2</div></div>
            <div class="chart-item"><div class="char-key">E</div><div class="hex-val">3</div></div>
            <div class="chart-item"><div class="char-key">A</div><div class="hex-val">4</div></div>
            <div class="chart-item"><div class="char-key">S</div><div class="hex-val">5</div></div>
            <div class="chart-item"><div class="char-key">G / b</div><div class="hex-val">6</div></div>
            <div class="chart-item"><div class="char-key">T</div><div class="hex-val">7</div></div>
            <div class="chart-item"><div class="char-key">B</div><div class="hex-val">8</div></div>
            <div class="chart-item"><div class="char-key">g / q</div><div class="hex-val">9</div></div>
            <div class="chart-item"><div class="char-key">SPACE</div><div class="hex-val">:</div></div>
        </div>

        <h3 style="margin-top: 3rem; border-top: 1px solid #30363d; padding-top: 2rem;">IPv6 Subnetting & CIDR Notation</h3>
        <p>In IPv6, addresses are split into two parts: the <strong>Network Prefix</strong> (where you are) and the <strong>Interface ID</strong> (who you are). The slash notation (e.g., <code>/64</code>) tells you how many bits belong to the network.</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1.5rem;">
            <div class="result-card" style="padding: 1rem;">
                <span class="card-label" style="position:static; margin-bottom:0.5rem; display:inline-block;">/32 (ISP Allocation)</span>
                <div style="font-size: 0.9rem; color: #8b949e;">Huge block given to ISPs. Contains 4 billion /64 subnets.</div>
            </div>
            <div class="result-card" style="padding: 1rem;">
                <span class="card-label" style="position:static; margin-bottom:0.5rem; display:inline-block;">/48 (Site Allocation)</span>
                <div style="font-size: 0.9rem; color: #8b949e;">Standard block for a company or home. Contains 65,536 subnets.</div>
            </div>
            <div class="result-card" style="padding: 1rem; border-color: var(--term-green);">
                <span class="card-label" style="position:static; margin-bottom:0.5rem; display:inline-block; color: var(--term-green); border-color: var(--term-dim);">/64 (Standard Subnet)</span>
                <div style="font-size: 0.9rem; color: #fff;">The industry standard for a single LAN (VLAN). <strong>Vanity addresses</strong> usually occupy the last 64 bits of this.</div>
            </div>
        </div>

        <div class="seo-content">
            <p><strong>Pro Tip:</strong> Use the "Creative Mode" suggestions if your name contains difficult characters like K, M, or W. We use advanced phonetic and visual mappings (like W &rarr; 33) to ensure you always get a valid subnet or interface ID.</p>
        </div>
    </div>

    <footer>
        &copy; 2026 IPv6Gen.net. Free tool for generating Vanity IPv6 Addresses, Hexspeak, and Subnet definitions. 
        <br>Compatible with RFC 5952 text representation standards.
    </footer>
</div>

<div id="toast">Address Copied to Clipboard!</div>

<script>
class Logic {
    constructor() {
        this.leetMap = {
            'o': '0', 'i': '1', 'l': '1', 'z': '2', 'r': '2',
            'e': '3', 'a': '4', 's': '5', 'g': '6', 'b': '8',
            't': '7', 'q': '9'
        };
        
        this.creativeMap = {
            'h': '11', 'j': '1', 'k': 'c', 'm': 'aa', 'n': '17', 
            'p': '9', 'u': 'c', 'v': 'c', 'w': '33', 'x': '8', 'y': '7'
        };

        this.hexSynonyms = {
            'kill': 'dead', 'die': 'dead', 'eat': 'feed', 'drink': 'cafe',
            'coffee': 'cafe', 'tea': 'cafe', 'code': 'c0de', 'hack': 'hax',
            'cool': 'c00l', 'king': 'ace', 'win': 'ace', 'sad': 'bad',
            'error': 'bad', 'fail': 'bad'
        };
    }

    // --- SECURITY: Utility to escape HTML ---
    escape(str) {
        if (!str) return '';
        return str.toString()
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    toHex(str) {
        let hex = '';
        for(let i=0; i<str.length; i++) {
            hex += str.charCodeAt(i).toString(16);
        }
        return hex;
    }

    toLeet(str, useCreative = false) {
        let res = [];
        let valid = true;
        
        for (let char of str.toLowerCase()) {
            if (/[0-9a-f]/.test(char)) {
                res.push({char: char, valid: true});
            } else if (this.leetMap[char]) {
                res.push({char: this.leetMap[char], valid: true});
            } else if (char === ' ') {
                res.push({char: ':', valid: true, isSep: true});
            } else if (useCreative && this.creativeMap[char]) {
                res.push({char: this.creativeMap[char], valid: true, isCreative: true});
            } else {
                res.push({char: char, valid: false});
                valid = false;
            }
        }
        return { res, valid };
    }

    formatSmart(rawStr) {
        let parts = rawStr.split(':');
        let finalParts = [];
        parts.forEach(part => {
             if(part.length > 0) {
                 for (let i = 0; i < part.length; i += 4) {
                    finalParts.push(part.substring(i, i + 4));
                }
             }
        });
        return finalParts.join(':');
    }
    
    getSynonyms(text) {
        const words = text.toLowerCase().split(' ');
        let suggestions = [];
        words.forEach(word => {
            if(this.hexSynonyms[word]) {
                suggestions.push({
                    orig: word,
                    rep: this.hexSynonyms[word]
                });
            }
        });
        return suggestions;
    }
}

const logic = new Logic();
const ui = {
    prefix: document.getElementById('prefixInput'),
    input: document.getElementById('textInput'),
    leetOut: document.getElementById('leetOutput'),
    asciiOut: document.getElementById('asciiOutput'),
    suggBox: document.getElementById('suggestionsBox'),
    suggList: document.getElementById('suggestionsList'),
    creativeToggle: document.getElementById('creativeToggle'),
    toast: document.getElementById('toast')
};

function updateURL(prefix, text) {
    const params = new URLSearchParams();
    if(prefix !== '2001:db8') params.set('pfx', prefix);
    if(text) params.set('txt', text);
    if(ui.creativeToggle.checked) params.set('c', '1');
    const newUrl = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
    window.history.replaceState({}, '', newUrl);
}

function loadFromURL() {
    const params = new URLSearchParams(window.location.search);
    if(params.has('pfx')) ui.prefix.value = params.get('pfx');
    if(params.has('txt')) ui.input.value = params.get('txt');
    if(params.has('c')) ui.creativeToggle.checked = true;
    render();
}

function render() {
    // SECURITY: Read values, but they must be escaped before HTML insertion
    const text = ui.input.value;
    const prefix = ui.prefix.value.trim() || '2001:db8';
    
    // Validating prefix format (client-side only for UI feedback)
    const isPrefixValid = /^[0-9a-fA-F:]+$/.test(prefix);
    if(!isPrefixValid) ui.prefix.classList.add('invalid');
    else ui.prefix.classList.remove('invalid');

    updateURL(prefix, text);

    // SECURITY: Escape prefix before putting in HTML
    const safePrefix = logic.escape(prefix);
    const prefixHtml = `<span class="prefix-part">${safePrefix}::</span>`;

    if (!text) {
        ui.leetOut.innerHTML = prefixHtml + '<span class="vanity-part" style="opacity:0.3">vanity</span>';
        ui.asciiOut.innerHTML = prefixHtml + '<span class="vanity-part" style="opacity:0.3">vanity</span>';
        ui.suggBox.style.display = 'none';
        return;
    }

    // --- ASCII Mode ---
    const asciiHex = logic.toHex(text);
    const asciiFmt = logic.formatSmart(asciiHex);
    // Safe because hex output is 0-9a-f
    ui.asciiOut.innerHTML = prefixHtml + `<span class="vanity-part mode-ascii">${asciiFmt}</span>`;

    // --- Leet Mode ---
    const useCreative = ui.creativeToggle.checked;
    const { res, valid } = logic.toLeet(text, useCreative);
    
    let leetHtml = "";
    res.forEach(item => {
        // SECURITY: Escape every char before rendering
        const safeChar = logic.escape(item.char);
        if(item.valid) {
            leetHtml += item.isSep ? '<span class="sep-part">:</span>' : safeChar;
        } else {
            leetHtml += `<span class="error-part">${safeChar}</span>`;
        }
    });

    ui.leetOut.innerHTML = prefixHtml + `<span class="vanity-part">${leetHtml}</span>`;

    // Suggestions Logic
    ui.suggList.innerHTML = '';
    let hasSuggestions = false;

    const synonyms = logic.getSynonyms(text);
    if(synonyms.length > 0) {
        let newText = text.toLowerCase();
        let displayStr = "";
        synonyms.forEach(s => {
            newText = newText.replace(s.orig, s.rep);
            displayStr += `${logic.escape(s.orig)} -> ${s.rep}, `;
        });
        const synRes = logic.toLeet(newText, true); 
        let val = synRes.res.map(r => r.char).join('');
        addSuggestion("Try Synonym / Hacker Slang", val, safePrefix, `Found synonyms: ${displayStr.slice(0, -2)}`);
        hasSuggestions = true;
    }

    if (!valid && !useCreative) {
        const creativeRes = logic.toLeet(text, true);
        if(creativeRes.valid) {
            let val = creativeRes.res.map(r => r.char).join('');
            addSuggestion("Enable Creative Mode", val, safePrefix, "Maps phonetic/visual matches");
            hasSuggestions = true;
        }
    }
    
    if(!valid) {
        const strictRes = logic.toLeet(text, false);
        let filledStr = strictRes.res.map(r => r.valid ? r.char : '0').join('');
        addSuggestion("Replace invalid with '0'", filledStr, safePrefix);
        
        let skippedStr = strictRes.res.filter(r => r.valid).map(r => r.char).join('');
        if(skippedStr) addSuggestion("Remove invalid chars", skippedStr, safePrefix);
        
        hasSuggestions = true;
    }

    ui.suggBox.style.display = hasSuggestions ? 'block' : 'none';
}

function addSuggestion(label, val, safePrefix, subLabel = "") {
    // val is strictly hex chars (safe)
    const fmt = logic.formatSmart(val);
    const div = document.createElement('div');
    div.className = 'suggestion-item';
    // Label and Sublabel are static or synonyms (escaped above)
    div.innerHTML = `
        <div style="flex-grow:1">
            <div class="sugg-val">${safePrefix}::${fmt}</div>
        </div>
        <div style="text-align:right">
            <div class="sugg-label">${label}</div>
            ${subLabel ? `<div class="sugg-diff">${subLabel}</div>` : ''}
        </div>
    `;
    // We need unescaped text for clipboard? No, clipboard wants clean text.
    // safePrefix might have &lt; in it if user is malicious, but we don't want to copy &lt; to clipboard.
    // Actually we want to copy the *text* value of prefix.
    const rawPrefix = ui.prefix.value.trim() || '2001:db8';
    
    div.addEventListener('click', () => copyToClipboard(`${rawPrefix}::${fmt}`));
    ui.suggList.appendChild(div);
}

function copyToClipboard(text) {
    navigator.clipboard.writeText(text);
    const t = ui.toast;
    t.className = "show";
    setTimeout(() => { t.className = t.className.replace("show", ""); }, 3000);
}

// Event Listeners
ui.input.addEventListener('input', render);
ui.prefix.addEventListener('input', render);
ui.creativeToggle.addEventListener('change', render);

[ui.leetOut, ui.asciiOut].forEach(el => {
    el.parentNode.addEventListener('click', () => copyToClipboard(el.innerText));
});

window.addEventListener('load', loadFromURL);

</script>
</body>
</html>